package views

import (
	"fmt"
	"math/rand"
	"modulos/models"
	"strconv"
	"sync"
	"time"

	"github.com/faiface/pixel"
	"github.com/faiface/pixel/imdraw"
	"github.com/faiface/pixel/pixelgl"
	"github.com/faiface/pixel/text"
	"golang.org/x/image/colornames"
	"golang.org/x/image/font/basicfont"
)

const (
	windowWidth  = 1000
	windowHeight = 600
	vehicleSize  = 30
)

var entranceMutex sync.Mutex
var autosEnEspera []*models.Auto

func VehicleArrival(estacionamiento *models.Estacionamiento) {
	rand.Seed(time.Now().UnixNano())

	autoCounter := 1

	for {
		auto := &models.Auto{PosX: -40.0 - 10.0, PosY: windowHeight/2 + 80.0/2, Dir: 1, Numero: autoCounter}
		autosEnEspera = append(autosEnEspera, auto)
		autoCounter++

		pos := estacionamiento.Entrar(auto)

		if pos != -1 {
			entranceMutex.Lock()

			go func(p int) {
				defer entranceMutex.Unlock()
				time.Sleep(time.Duration(rand.Intn(15)+5) * time.Second)
				estacionamiento.Salir(p)
			}(pos)
		}

		time.Sleep(time.Millisecond * 1500)
	}
}

func Run() {
	cfg := pixelgl.WindowConfig{
		Title:  "Estacionamiento",
		Bounds: pixel.R(0, 0, windowWidth, windowHeight),
		VSync:  true,
	}
	win, err := pixelgl.NewWindow(cfg)
	if err != nil {
		panic(err)
	}

	estacionamiento := models.NuevoEstacionamiento(20)
	var mutex sync.Mutex

	go VehicleArrival(estacionamiento)

	entradaX := float64(50)
	salidaX := float64(950)

	// Cargar una fuente
	atlas := text.NewAtlas(basicfont.Face7x13, text.ASCII)

	for !win.Closed() {
		win.Clear(colornames.Black)

		mutex.Lock()

		for i := 0; i < estacionamiento.Espacios; i++ {
			posX := float64(50 + i*40)
			posY := float64(windowHeight / 2)

			rect := pixel.R(posX-float64(vehicleSize)/2, posY-float64(vehicleSize)/2, posX+float64(vehicleSize)/2, posY+float64(vehicleSize)/2)
			imd := imdraw.New(nil)
			imd.Color = colornames.Gray
			imd.Push(rect.Min, rect.Max)
			imd.Rectangle(0)
			imd.Draw(win)
		}

		for i, auto := range estacionamiento.Ocupados {
			if auto != nil {
				posX := float64(50 + i*40)
				posY := float64(windowHeight / 2)

				rect := pixel.R(posX-float64(vehicleSize)/2, posY-float64(vehicleSize)/2, posX+float64(vehicleSize)/2, posY+float64(vehicleSize)/2)
				imd := imdraw.New(nil)
				imd.Color = colornames.Blue
				imd.Push(rect.Min, rect.Max)
				imd.Rectangle(0)
				imd.Draw(win)
			}
		}

		mutex.Unlock()

		entranceMutex.Lock()

		rectEntrada := pixel.R(entradaX-float64(vehicleSize)/2, float64(0), entradaX+float64(vehicleSize)/2, float64(windowHeight))
		imdEntrada := imdraw.New(nil)
		imdEntrada.Color = colornames.Green
		imdEntrada.Push(rectEntrada.Min, rectEntrada.Max)
		imdEntrada.Rectangle(0)
		imdEntrada.Draw(win)

		entranceMutex.Unlock()

		rectSalida := pixel.R(salidaX-float64(vehicleSize)/2, float64(0), salidaX+float64(vehicleSize)/2, float64(windowHeight))
		imdSalida := imdraw.New(nil)
		imdSalida.Color = colornames.Red
		imdSalida.Push(rectSalida.Min, rectSalida.Max)
		imdSalida.Rectangle(0)
		imdSalida.Draw(win)

		for _, auto := range autosEnEspera {
			posX := float64(10)                  // PosiciÃ³n X para los autos en espera
			posY := float64(20 + auto.Numero*30) // Espaciar los autos verticalmente

			rect := pixel.R(posX-float64(vehicleSize)/2, posY-float64(vehicleSize)/2, posX+float64(vehicleSize)/2, posY+float64(vehicleSize)/2)
			imd := imdraw.New(nil)
			imd.Color = colornames.Orange // Color para autos en espera
			imd.Push(rect.Min, rect.Max)
			imd.Rectangle(0)
			imd.Draw(win)

			txt := text.New(pixel.V(posX, posY), atlas)
			txt.Color = colornames.White
			txt.WriteString(strconv.Itoa(auto.Numero))
			txt.Draw(win, pixel.IM.Scaled(txt.Orig, 1))
		}

		win.Update()
	}
}

func Init() {
	fmt.Println("El simulador ha iniciado")
}
